"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/game-logic.ts":
/*!***************************!*\
  !*** ./lib/game-logic.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GAME_CONFIG: () => (/* binding */ GAME_CONFIG),\n/* harmony export */   gameLogic: () => (/* binding */ gameLogic)\n/* harmony export */ });\n// Updated game config for DRX mining system\nconst GAME_CONFIG = {\n    REFERRAL_BONUS: 200,\n    BASE_MINING_RATE: 0.001,\n    WELCOME_BONUS: 100,\n    JACKPOT_COOLDOWN: 3600000,\n    MIN_CLAIM_TIME: 1800,\n    MAX_MINING_TIME: 86400,\n    DAILY_MINING_REWARD: 100,\n    CRITICAL_CHANCE: 0.02,\n    JACKPOT_CHANCE: 0.0005,\n    MAX_LEVEL: 50,\n    XP_PER_LEVEL: 100,\n    DRX_TO_UC_RATE: 1,\n    BASE_XP_REWARD: 50,\n    REFERRAL_XP_BONUS: 60\n};\nconst gameLogic = {\n    calculateMiningRewards (user, miningDuration) {\n        const baseRate = user.miningRate || GAME_CONFIG.BASE_MINING_RATE;\n        let earned = baseRate * miningDuration // duration in seconds\n        ;\n        let type = \"normal\";\n        // Calculate XP based on mining duration (30 minutes = 30 XP base)\n        let xp = Math.floor(miningDuration / 1800 * GAME_CONFIG.BASE_XP_REWARD) // 1800 seconds = 30 minutes\n        ;\n        // Apply boost multipliers to XP\n        const miningSpeedMultiplier = user.boosts.miningSpeedLevel || 1;\n        const miningRateMultiplier = user.boosts.miningRateLevel || 1;\n        xp = Math.floor(xp * Math.max(miningSpeedMultiplier, miningRateMultiplier) * 0.5);\n        // Bonus for 24h continuous mining\n        if (miningDuration >= GAME_CONFIG.MAX_MINING_TIME) {\n            earned += GAME_CONFIG.DAILY_MINING_REWARD;\n            xp += 100 // Bonus XP for 24h mining\n            ;\n            type = \"bonus\";\n        }\n        return {\n            earned,\n            type,\n            xp\n        };\n    },\n    calculateLevel (xp) {\n        let level = 1;\n        let remainingXP = xp;\n        let totalXPNeeded = 0;\n        while(remainingXP >= this.getXpForLevel(level)){\n            const xpForThisLevel = this.getXpForLevel(level);\n            remainingXP -= xpForThisLevel;\n            totalXPNeeded += xpForThisLevel;\n            level++;\n        }\n        return {\n            level,\n            currentXP: remainingXP,\n            xpForNext: this.getXpForLevel(level)\n        };\n    },\n    getXpForLevel (level) {\n        if (level === 1) return 100;\n        // Each level requires 10x more XP than the previous\n        return 100 * Math.pow(10, level - 1);\n    },\n    calculateRank (totalEarned) {\n        var _ranks_;\n        const ranks = [\n            {\n                threshold: 0,\n                title: \"Rookie Miner\",\n                icon: \"ü•â\"\n            },\n            {\n                threshold: 1000,\n                title: \"Bronze Miner\",\n                icon: \"ü•â\"\n            },\n            {\n                threshold: 5000,\n                title: \"Silver Miner\",\n                icon: \"ü•à\"\n            },\n            {\n                threshold: 15000,\n                title: \"Gold Miner\",\n                icon: \"ü•á\"\n            },\n            {\n                threshold: 50000,\n                title: \"Platinum Miner\",\n                icon: \"üíé\"\n            },\n            {\n                threshold: 150000,\n                title: \"Diamond Miner\",\n                icon: \"üíé\"\n            },\n            {\n                threshold: 500000,\n                title: \"Master Miner\",\n                icon: \"üëë\"\n            },\n            {\n                threshold: 1500000,\n                title: \"Grandmaster Miner\",\n                icon: \"üëë\"\n            },\n            {\n                threshold: 5000000,\n                title: \"Legend Miner\",\n                icon: \"üèÜ\"\n            },\n            {\n                threshold: 15000000,\n                title: \"Mythical Miner\",\n                icon: \"‚≠ê\"\n            },\n            {\n                threshold: 50000000,\n                title: \"Ultimate Miner\",\n                icon: \"üåü\"\n            }\n        ];\n        let currentRank = 1;\n        let currentTitle = ranks[0].title;\n        let currentIcon = ranks[0].icon;\n        let nextRankAt = ((_ranks_ = ranks[1]) === null || _ranks_ === void 0 ? void 0 : _ranks_.threshold) || 0;\n        for(let i = 0; i < ranks.length; i++){\n            if (totalEarned >= ranks[i].threshold) {\n                var _ranks_1;\n                currentRank = i + 1;\n                currentTitle = ranks[i].title;\n                currentIcon = ranks[i].icon;\n                nextRankAt = ((_ranks_1 = ranks[i + 1]) === null || _ranks_1 === void 0 ? void 0 : _ranks_1.threshold) || ranks[i].threshold;\n            } else {\n                break;\n            }\n        }\n        return {\n            rank: currentRank,\n            title: currentTitle,\n            nextRankAt,\n            icon: currentIcon\n        };\n    },\n    getBoostCost (boostType, currentLevel) {\n        const baseCosts = {\n            miningSpeed: 100,\n            claimTime: 150,\n            miningRate: 200\n        };\n        const baseCost = baseCosts[boostType];\n        // Each level costs 2x more than the previous\n        return Math.floor(baseCost * Math.pow(2, currentLevel - 1));\n    },\n    formatNumber (num) {\n        const safeNum = typeof num === \"number\" ? num : 0;\n        if (safeNum >= 1000000000) {\n            return Math.floor(safeNum / 1000000000) + \"B\";\n        } else if (safeNum >= 1000000) {\n            return Math.floor(safeNum / 1000000) + \"M\";\n        } else if (safeNum >= 1000) {\n            return Math.floor(safeNum / 1000) + \"K\";\n        }\n        return Math.floor(safeNum).toString();\n    },\n    formatNumberPrecise (num) {\n        const safeNum = typeof num === \"number\" ? num : 0;\n        return safeNum.toFixed(8);\n    },\n    formatTime (seconds) {\n        const hours = Math.floor(seconds / 3600);\n        const minutes = Math.floor(seconds % 3600 / 60);\n        const secs = seconds % 60;\n        if (hours > 0) {\n            return \"\".concat(hours.toString().padStart(2, '0'), \":\").concat(minutes.toString().padStart(2, '0'), \":\").concat(secs.toString().padStart(2, '0'));\n        } else {\n            return \"\".concat(minutes.toString().padStart(2, '0'), \":\").concat(secs.toString().padStart(2, '0'));\n        }\n    },\n    canClaimMining (user) {\n        if (!user.isMining || !user.miningStartTime) return false;\n        const now = Date.now();\n        const miningDuration = Math.floor((now - user.miningStartTime) / 1000);\n        return miningDuration >= (user.minClaimTime || GAME_CONFIG.MIN_CLAIM_TIME);\n    },\n    getMiningDuration (user) {\n        if (!user.isMining || !user.miningStartTime) return 0;\n        const now = Date.now();\n        return Math.floor((now - user.miningStartTime) / 1000);\n    },\n    calculatePendingRewards (user) {\n        const duration = this.getMiningDuration(user);\n        if (duration === 0) return 0;\n        const { earned } = this.calculateMiningRewards(user, duration);\n        return earned;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SyxDQUFDLENBQUNtRCxNQUFNM0QsS0FBSzBELGVBQWUsSUFBSTtRQUVqRSxPQUFPekQsa0JBQW1CRCxDQUFBQSxLQUFLNkQsWUFBWSxJQUFJOUUsWUFBWUssY0FBYztJQUMzRTtJQUVBMEUsbUJBQWtCOUQsSUFBVTtRQUMxQixJQUFJLENBQUNBLEtBQUt5RCxRQUFRLElBQUksQ0FBQ3pELEtBQUswRCxlQUFlLEVBQUUsT0FBTztRQUVwRCxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLE9BQU9wRCxLQUFLQyxLQUFLLENBQUMsQ0FBQ21ELE1BQU0zRCxLQUFLMEQsZUFBZSxJQUFJO0lBQ25EO0lBRUFLLHlCQUF3Qi9ELElBQVU7UUFDaEMsTUFBTWdFLFdBQVcsSUFBSSxDQUFDRixpQkFBaUIsQ0FBQzlEO1FBQ3hDLElBQUlnRSxhQUFhLEdBQUcsT0FBTztRQUUzQixNQUFNLEVBQUU1RCxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUNMLHNCQUFzQixDQUFDQyxNQUFNZ0U7UUFDckQsT0FBTzVEO0lBQ1Q7QUFDRixFQUFDIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L2xpYi9nYW1lLWxvZ2ljLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVXNlciB9IGZyb20gXCJAL3R5cGVzXCJcblxuLy8gVXBkYXRlZCBnYW1lIGNvbmZpZyBmb3IgRFJYIG1pbmluZyBzeXN0ZW1cbmV4cG9ydCBjb25zdCBHQU1FX0NPTkZJRyA9IHtcbiAgUkVGRVJSQUxfQk9OVVM6IDIwMCwgLy8gRFJYIChjaGFuZ2VkIGZyb20gNTAwIHRvIDIwMClcbiAgQkFTRV9NSU5JTkdfUkFURTogMC4wMDEsIC8vIERSWCBwZXIgc2Vjb25kXG4gIFdFTENPTUVfQk9OVVM6IDEwMCwgLy8gRFJYXG4gIEpBQ0tQT1RfQ09PTERPV046IDM2MDAwMDAsIC8vIDEgaG91clxuICBNSU5fQ0xBSU1fVElNRTogMTgwMCwgLy8gMzAgbWludXRlcyBtaW5pbXVtIG1pbmluZyB0aW1lXG4gIE1BWF9NSU5JTkdfVElNRTogODY0MDAsIC8vIDI0IGhvdXJzIG1heGltdW0gbWluaW5nIHRpbWVcbiAgREFJTFlfTUlOSU5HX1JFV0FSRDogMTAwLCAvLyBEUlggZm9yIDMwbWluIGNvbnRpbnVvdXMgbWluaW5nXG4gIENSSVRJQ0FMX0NIQU5DRTogMC4wMixcbiAgSkFDS1BPVF9DSEFOQ0U6IDAuMDAwNSxcbiAgTUFYX0xFVkVMOiA1MCxcbiAgWFBfUEVSX0xFVkVMOiAxMDAsXG4gIERSWF9UT19VQ19SQVRFOiAxLCAvLyAxIERSWCA9IDEgVUMgKGNhbiBiZSBjaGFuZ2VkKVxuICBCQVNFX1hQX1JFV0FSRDogNTAsIC8vIEJhc2UgWFAgZm9yIDMwIG1pbnV0ZXMgb2YgbWluaW5nXG4gIFJFRkVSUkFMX1hQX0JPTlVTOiA2MCwgLy8gWFAgYm9udXMgZm9yIHJlZmVycmFsc1xufVxuXG5leHBvcnQgY29uc3QgZ2FtZUxvZ2ljID0ge1xuICBjYWxjdWxhdGVNaW5pbmdSZXdhcmRzKHVzZXI6IFVzZXIsIG1pbmluZ0R1cmF0aW9uOiBudW1iZXIpOiB7IGVhcm5lZDogbnVtYmVyOyB0eXBlOiBcIm5vcm1hbFwiIHwgXCJib251c1wiOyB4cDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGJhc2VSYXRlID0gdXNlci5taW5pbmdSYXRlIHx8IEdBTUVfQ09ORklHLkJBU0VfTUlOSU5HX1JBVEVcbiAgICBsZXQgZWFybmVkID0gYmFzZVJhdGUgKiBtaW5pbmdEdXJhdGlvbiAvLyBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAgbGV0IHR5cGU6IFwibm9ybWFsXCIgfCBcImJvbnVzXCIgPSBcIm5vcm1hbFwiXG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIFhQIGJhc2VkIG9uIG1pbmluZyBkdXJhdGlvbiAoMzAgbWludXRlcyA9IDMwIFhQIGJhc2UpXG4gICAgbGV0IHhwID0gTWF0aC5mbG9vcigobWluaW5nRHVyYXRpb24gLyAxODAwKSAqIEdBTUVfQ09ORklHLkJBU0VfWFBfUkVXQVJEKSAvLyAxODAwIHNlY29uZHMgPSAzMCBtaW51dGVzXG4gICAgXG4gICAgLy8gQXBwbHkgYm9vc3QgbXVsdGlwbGllcnMgdG8gWFBcbiAgICBjb25zdCBtaW5pbmdTcGVlZE11bHRpcGxpZXIgPSB1c2VyLmJvb3N0cy5taW5pbmdTcGVlZExldmVsIHx8IDFcbiAgICBjb25zdCBtaW5pbmdSYXRlTXVsdGlwbGllciA9IHVzZXIuYm9vc3RzLm1pbmluZ1JhdGVMZXZlbCB8fCAxXG4gICAgeHAgPSBNYXRoLmZsb29yKHhwICogTWF0aC5tYXgobWluaW5nU3BlZWRNdWx0aXBsaWVyLCBtaW5pbmdSYXRlTXVsdGlwbGllcikgKiAwLjUpXG5cbiAgICAvLyBCb251cyBmb3IgMjRoIGNvbnRpbnVvdXMgbWluaW5nXG4gICAgaWYgKG1pbmluZ0R1cmF0aW9uID49IEdBTUVfQ09ORklHLk1BWF9NSU5JTkdfVElNRSkge1xuICAgICAgZWFybmVkICs9IEdBTUVfQ09ORklHLkRBSUxZX01JTklOR19SRVdBUkRcbiAgICAgIHhwICs9IDEwMCAvLyBCb251cyBYUCBmb3IgMjRoIG1pbmluZ1xuICAgICAgdHlwZSA9IFwiYm9udXNcIlxuICAgIH1cblxuICAgIHJldHVybiB7IGVhcm5lZCwgdHlwZSwgeHAgfVxuICB9LFxuXG4gIGNhbGN1bGF0ZUxldmVsKHhwOiBudW1iZXIpOiB7IGxldmVsOiBudW1iZXI7IGN1cnJlbnRYUDogbnVtYmVyOyB4cEZvck5leHQ6IG51bWJlciB9IHtcbiAgICBsZXQgbGV2ZWwgPSAxXG4gICAgbGV0IHJlbWFpbmluZ1hQID0geHBcbiAgICBsZXQgdG90YWxYUE5lZWRlZCA9IDBcblxuICAgIHdoaWxlIChyZW1haW5pbmdYUCA+PSB0aGlzLmdldFhwRm9yTGV2ZWwobGV2ZWwpKSB7XG4gICAgICBjb25zdCB4cEZvclRoaXNMZXZlbCA9IHRoaXMuZ2V0WHBGb3JMZXZlbChsZXZlbClcbiAgICAgIHJlbWFpbmluZ1hQIC09IHhwRm9yVGhpc0xldmVsXG4gICAgICB0b3RhbFhQTmVlZGVkICs9IHhwRm9yVGhpc0xldmVsXG4gICAgICBsZXZlbCsrXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsLFxuICAgICAgY3VycmVudFhQOiByZW1haW5pbmdYUCxcbiAgICAgIHhwRm9yTmV4dDogdGhpcy5nZXRYcEZvckxldmVsKGxldmVsKSxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0WHBGb3JMZXZlbChsZXZlbDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAobGV2ZWwgPT09IDEpIHJldHVybiAxMDBcbiAgICAvLyBFYWNoIGxldmVsIHJlcXVpcmVzIDEweCBtb3JlIFhQIHRoYW4gdGhlIHByZXZpb3VzXG4gICAgcmV0dXJuIDEwMCAqIE1hdGgucG93KDEwLCBsZXZlbCAtIDEpXG4gIH0sXG5cbiAgY2FsY3VsYXRlUmFuayh0b3RhbEVhcm5lZDogbnVtYmVyKTogeyByYW5rOiBudW1iZXI7IHRpdGxlOiBzdHJpbmc7IG5leHRSYW5rQXQ6IG51bWJlcjsgaWNvbjogc3RyaW5nIH0ge1xuICAgIGNvbnN0IHJhbmtzID0gW1xuICAgICAgeyB0aHJlc2hvbGQ6IDAsIHRpdGxlOiBcIlJvb2tpZSBNaW5lclwiLCBpY29uOiBcIvCfpYlcIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDEwMDAsIHRpdGxlOiBcIkJyb256ZSBNaW5lclwiLCBpY29uOiBcIvCfpYlcIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDUwMDAsIHRpdGxlOiBcIlNpbHZlciBNaW5lclwiLCBpY29uOiBcIvCfpYhcIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDE1MDAwLCB0aXRsZTogXCJHb2xkIE1pbmVyXCIsIGljb246IFwi8J+lh1wiIH0sXG4gICAgICB7IHRocmVzaG9sZDogNTAwMDAsIHRpdGxlOiBcIlBsYXRpbnVtIE1pbmVyXCIsIGljb246IFwi8J+SjlwiIH0sXG4gICAgICB7IHRocmVzaG9sZDogMTUwMDAwLCB0aXRsZTogXCJEaWFtb25kIE1pbmVyXCIsIGljb246IFwi8J+SjlwiIH0sXG4gICAgICB7IHRocmVzaG9sZDogNTAwMDAwLCB0aXRsZTogXCJNYXN0ZXIgTWluZXJcIiwgaWNvbjogXCLwn5GRXCIgfSxcbiAgICAgIHsgdGhyZXNob2xkOiAxNTAwMDAwLCB0aXRsZTogXCJHcmFuZG1hc3RlciBNaW5lclwiLCBpY29uOiBcIvCfkZFcIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDUwMDAwMDAsIHRpdGxlOiBcIkxlZ2VuZCBNaW5lclwiLCBpY29uOiBcIvCfj4ZcIiB9LFxuICAgICAgeyB0aHJlc2hvbGQ6IDE1MDAwMDAwLCB0aXRsZTogXCJNeXRoaWNhbCBNaW5lclwiLCBpY29uOiBcIuKtkFwiIH0sXG4gICAgICB7IHRocmVzaG9sZDogNTAwMDAwMDAsIHRpdGxlOiBcIlVsdGltYXRlIE1pbmVyXCIsIGljb246IFwi8J+Mn1wiIH0sXG4gICAgXVxuXG4gICAgbGV0IGN1cnJlbnRSYW5rID0gMVxuICAgIGxldCBjdXJyZW50VGl0bGUgPSByYW5rc1swXS50aXRsZVxuICAgIGxldCBjdXJyZW50SWNvbiA9IHJhbmtzWzBdLmljb25cbiAgICBsZXQgbmV4dFJhbmtBdCA9IHJhbmtzWzFdPy50aHJlc2hvbGQgfHwgMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRvdGFsRWFybmVkID49IHJhbmtzW2ldLnRocmVzaG9sZCkge1xuICAgICAgICBjdXJyZW50UmFuayA9IGkgKyAxXG4gICAgICAgIGN1cnJlbnRUaXRsZSA9IHJhbmtzW2ldLnRpdGxlXG4gICAgICAgIGN1cnJlbnRJY29uID0gcmFua3NbaV0uaWNvblxuICAgICAgICBuZXh0UmFua0F0ID0gcmFua3NbaSArIDFdPy50aHJlc2hvbGQgfHwgcmFua3NbaV0udGhyZXNob2xkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByYW5rOiBjdXJyZW50UmFuayxcbiAgICAgIHRpdGxlOiBjdXJyZW50VGl0bGUsXG4gICAgICBuZXh0UmFua0F0LFxuICAgICAgaWNvbjogY3VycmVudEljb24sXG4gICAgfVxuICB9LFxuXG4gIGdldEJvb3N0Q29zdChib29zdFR5cGU6IFwibWluaW5nU3BlZWRcIiB8IFwiY2xhaW1UaW1lXCIgfCBcIm1pbmluZ1JhdGVcIiwgY3VycmVudExldmVsOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VDb3N0cyA9IHtcbiAgICAgIG1pbmluZ1NwZWVkOiAxMDAsXG4gICAgICBjbGFpbVRpbWU6IDE1MCxcbiAgICAgIG1pbmluZ1JhdGU6IDIwMCxcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlQ29zdCA9IGJhc2VDb3N0c1tib29zdFR5cGVdXG4gICAgLy8gRWFjaCBsZXZlbCBjb3N0cyAyeCBtb3JlIHRoYW4gdGhlIHByZXZpb3VzXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoYmFzZUNvc3QgKiBNYXRoLnBvdygyLCBjdXJyZW50TGV2ZWwgLSAxKSlcbiAgfSxcblxuICBmb3JtYXROdW1iZXIobnVtOiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsKTogc3RyaW5nIHtcbiAgICBjb25zdCBzYWZlTnVtID0gdHlwZW9mIG51bSA9PT0gXCJudW1iZXJcIiA/IG51bSA6IDBcblxuICAgIGlmIChzYWZlTnVtID49IDEwMDAwMDAwMDApIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHNhZmVOdW0gLyAxMDAwMDAwMDAwKSArIFwiQlwiXG4gICAgfSBlbHNlIGlmIChzYWZlTnVtID49IDEwMDAwMDApIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHNhZmVOdW0gLyAxMDAwMDAwKSArIFwiTVwiXG4gICAgfSBlbHNlIGlmIChzYWZlTnVtID49IDEwMDApIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHNhZmVOdW0gLyAxMDAwKSArIFwiS1wiXG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKHNhZmVOdW0pLnRvU3RyaW5nKClcbiAgfSxcblxuICBmb3JtYXROdW1iZXJQcmVjaXNlKG51bTogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbCk6IHN0cmluZyB7XG4gICAgY29uc3Qgc2FmZU51bSA9IHR5cGVvZiBudW0gPT09IFwibnVtYmVyXCIgPyBudW0gOiAwXG4gICAgcmV0dXJuIHNhZmVOdW0udG9GaXhlZCg4KVxuICB9LFxuXG4gIGZvcm1hdFRpbWUoc2Vjb25kczogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBob3VycyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDM2MDApXG4gICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoKHNlY29uZHMgJSAzNjAwKSAvIDYwKVxuICAgIGNvbnN0IHNlY3MgPSBzZWNvbmRzICUgNjBcblxuICAgIGlmIChob3VycyA+IDApIHtcbiAgICAgIHJldHVybiBgJHtob3Vycy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7bWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7c2Vjcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7bWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7c2Vjcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YFxuICAgIH1cbiAgfSxcblxuICBjYW5DbGFpbU1pbmluZyh1c2VyOiBVc2VyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF1c2VyLmlzTWluaW5nIHx8ICF1c2VyLm1pbmluZ1N0YXJ0VGltZSkgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IG1pbmluZ0R1cmF0aW9uID0gTWF0aC5mbG9vcigobm93IC0gdXNlci5taW5pbmdTdGFydFRpbWUpIC8gMTAwMClcbiAgICBcbiAgICByZXR1cm4gbWluaW5nRHVyYXRpb24gPj0gKHVzZXIubWluQ2xhaW1UaW1lIHx8IEdBTUVfQ09ORklHLk1JTl9DTEFJTV9USU1FKVxuICB9LFxuXG4gIGdldE1pbmluZ0R1cmF0aW9uKHVzZXI6IFVzZXIpOiBudW1iZXIge1xuICAgIGlmICghdXNlci5pc01pbmluZyB8fCAhdXNlci5taW5pbmdTdGFydFRpbWUpIHJldHVybiAwXG4gICAgXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiBNYXRoLmZsb29yKChub3cgLSB1c2VyLm1pbmluZ1N0YXJ0VGltZSkgLyAxMDAwKVxuICB9LFxuXG4gIGNhbGN1bGF0ZVBlbmRpbmdSZXdhcmRzKHVzZXI6IFVzZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5nZXRNaW5pbmdEdXJhdGlvbih1c2VyKVxuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkgcmV0dXJuIDBcbiAgICBcbiAgICBjb25zdCB7IGVhcm5lZCB9ID0gdGhpcy5jYWxjdWxhdGVNaW5pbmdSZXdhcmRzKHVzZXIsIGR1cmF0aW9uKVxuICAgIHJldHVybiBlYXJuZWRcbiAgfSxcbn0iXSwibmFtZXMiOlsiR0FNRV9DT05GSUciLCJSRUZFUlJBTF9CT05VUyIsIkJBU0VfTUlOSU5HX1JBVEUiLCJXRUxDT01FX0JPTlVTIiwiSkFDS1BPVF9DT09MRE9XTiIsIk1JTl9DTEFJTV9USU1FIiwiTUFYX01JTklOR19USU1FIiwiREFJTFlfTUlOSU5HX1JFV0FSRCIsIkNSSVRJQ0FMX0NIQU5DRSIsIkpBQ0tQT1RfQ0hBTkNFIiwiTUFYX0xFVkVMIiwiWFBfUEVSX0xFVkVMIiwiRFJYX1RPX1VDX1JBVEUiLCJCQVNFX1hQX1JFV0FSRCIsIlJFRkVSUkFMX1hQX0JPTlVTIiwiZ2FtZUxvZ2ljIiwiY2FsY3VsYXRlTWluaW5nUmV3YXJkcyIsInVzZXIiLCJtaW5pbmdEdXJhdGlvbiIsImJhc2VSYXRlIiwibWluaW5nUmF0ZSIsImVhcm5lZCIsInR5cGUiLCJ4cCIsIk1hdGgiLCJmbG9vciIsIm1pbmluZ1NwZWVkTXVsdGlwbGllciIsImJvb3N0cyIsIm1pbmluZ1NwZWVkTGV2ZWwiLCJtaW5pbmdSYXRlTXVsdGlwbGllciIsIm1pbmluZ1JhdGVMZXZlbCIsIm1heCIsImNhbGN1bGF0ZUxldmVsIiwibGV2ZWwiLCJyZW1haW5pbmdYUCIsInRvdGFsWFBOZWVkZWQiLCJnZXRYcEZvckxldmVsIiwieHBGb3JUaGlzTGV2ZWwiLCJjdXJyZW50WFAiLCJ4cEZvck5leHQiLCJwb3ciLCJjYWxjdWxhdGVSYW5rIiwidG90YWxFYXJuZWQiLCJyYW5rcyIsInRocmVzaG9sZCIsInRpdGxlIiwiaWNvbiIsImN1cnJlbnRSYW5rIiwiY3VycmVudFRpdGxlIiwiY3VycmVudEljb24iLCJuZXh0UmFua0F0IiwiaSIsImxlbmd0aCIsInJhbmsiLCJnZXRCb29zdENvc3QiLCJib29zdFR5cGUiLCJjdXJyZW50TGV2ZWwiLCJiYXNlQ29zdHMiLCJtaW5pbmdTcGVlZCIsImNsYWltVGltZSIsImJhc2VDb3N0IiwiZm9ybWF0TnVtYmVyIiwibnVtIiwic2FmZU51bSIsInRvU3RyaW5nIiwiZm9ybWF0TnVtYmVyUHJlY2lzZSIsInRvRml4ZWQiLCJmb3JtYXRUaW1lIiwic2Vjb25kcyIsImhvdXJzIiwibWludXRlcyIsInNlY3MiLCJwYWRTdGFydCIsImNhbkNsYWltTWluaW5nIiwiaXNNaW5pbmciLCJtaW5pbmdTdGFydFRpbWUiLCJub3ciLCJEYXRlIiwibWluQ2xhaW1UaW1lIiwiZ2V0TWluaW5nRHVyYXRpb24iLCJjYWxjdWxhdGVQZW5kaW5nUmV3YXJkcyIsImR1cmF0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/game-logic.ts\n"));

/***/ })

});